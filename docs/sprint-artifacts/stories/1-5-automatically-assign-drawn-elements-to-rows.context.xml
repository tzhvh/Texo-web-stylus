<story-context id="{bmad_folder}/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>5</storyId>
    <title>Automatically Assign Drawn Elements to Rows</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-13</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/mser/Documents/cla/w/Texo-web-stylus/docs/sprint-artifacts/1-5-automatically-assign-drawn-elements-to-rows.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user</asA>
    <iWant>my drawn strokes to automatically belong to the correct row</iWant>
    <soThat>OCR processes the right content for each line</soThat>
    <tasks>Task 1: Create useRowSystem hook for canvas-row synchronization (AC: #1, #2)
- Subtask 1.1: Create `src/hooks/useRowSystem.js` file
- Subtask 1.2: Implement hook that takes ExcalidrawAPI and RowManager
- Subtask 1.3: Set up onChange event listener from Excalidraw
- Subtask 1.4: Implement element diff detection (new, modified, deleted)
- Subtask 1.5: Add 50ms debounce for rapid drawing scenarios

Task 2: Implement element assignment logic (AC: #1, #3)
- Subtask 2.1: Extract element center Y coordinate from bounding box
- Subtask 2.2: Call rowManager.assignElement() for each new/modified element
- Subtask 2.3: Handle element deletion via rowManager.removeElement()
- Subtask 2.4: Update component state with element-to-row mappings
- Subtask 2.5: Log assignment events for debugging

Task 3: Handle element movement and reassignment (AC: #4)
- Subtask 3.1: Detect when element's center Y crosses row boundary
- Subtask 3.2: Remove element from previous row's element list
- Subtask 3.3: Add element to new row's element list
- Subtask 3.4: Update both rows' lastModified timestamps
- Subtask 3.5: Reset OCR status for affected rows to 'pending'

Task 4: Ensure persistence through transformations (AC: #5)
- Subtask 4.1: Test row assignments survive pan operations
- Subtask 4.2: Test row assignments survive zoom operations
- Subtask 4.3: Verify row IDs remain stable during transformations
- Subtask 4.4: Test with extreme zoom levels (0.1x to 5x)
- Subtask 4.5: Validate performance during rapid pan/zoom

Task 5: Handle element deletion and undo/redo (AC: #6, #7)
- Subtask 5.1: Detect element deletion in onChange diff
- Subtask 5.2: Remove element ID from row's elementIds Set
- Subtask 5.3: Update row's lastModified timestamp
- Subtask 5.4: Test undo operation restores row assignments
- Subtask 5.5: Test redo operation reapplies row assignments

Task 6: Integrate with MagicCanvas component (AC: #1, #2)
- Subtask 6.1: Import and instantiate useRowSystem hook in MagicCanvas.jsx
- Subtask 6.2: Pass ExcalidrawAPI and RowManager to hook
- Subtask 6.3: Handle hook return values (row assignments, status updates)
- Subtask 6.4: Test integration with existing guide line system
- Subtask 6.5: Verify no conflicts with existing canvas functionality

Task 7: Add comprehensive testing
- Subtask 7.1: Unit tests for useRowSystem hook logic
- Subtask 7.2: Integration tests for element assignment workflow
- Subtask 7.3: Performance tests for rapid drawing scenarios
- Subtask 7.4: Edge case tests (elements spanning rows, rapid deletion)
- Subtask 7.5: Manual browser testing for complete user workflow</tasks>
  </story>

  <acceptanceCriteria>AC1: Given I draw on Magic Canvas When I create a new stroke element Then system automatically assigns it to the appropriate row based on its Y coordinate
AC2: And assignment happens within 100ms of stroke completion
AC3: And elements are assigned based on their center Y coordinate
AC4: And assignment updates if element is moved to different row
AC5: And assignment persists through pan/zoom operations
AC6: And erased elements are removed from their row's element list
AC7: And undo/redo operations correctly update row assignments</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Row System Capabilities (FR11-FR18)</section>
        <snippet>FR11: System automatically assigns drawn elements to rows based on Y-coordinate. FR12: Each row has a stable unique ID that persists across pan/zoom/reload. FR13: System maintains row metadata including Y-position, element IDs, OCR status, validation status, and transcribed LaTeX.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Magic Canvas - Decision Architecture</title>
        <section>Epic 1: Canvas Foundation & Row System</section>
        <snippet>RowManager class with Map storage for O(1) lookups. Row ID format: "row-{index}" (deterministic based on Y position). Element assignment: assignElement(element) method returns rowId. State synchronization: Unidirectional (Excalidraw → RowManager → IndexedDB).</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Magic Canvas - Decision Architecture</title>
        <section>Pattern 3: State Synchronization</section>
        <snippet>Excalidraw → RowManager (immediate): Trigger: Excalidraw onChange event. Action: Diff elements, call rowManager.assignElement(), updateRow(), removeElement(). Timing: Synchronous, &lt;100ms.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/utils/rowManager.js</path>
        <kind>utility class</kind>
        <symbol>RowManager</symbol>
        <lines>45-169</lines>
        <reason>Provides assignElement() method for automatic element-to-row assignment based on Y coordinate. Includes getRowForY() for row determination and removeElement() for cleanup. Handle multi-row spanning elements with center Y coordinate strategy and conflict resolution for overlapping elements.</reason>
      </artifact>
      <artifact>
        <path>src/utils/rowManager.js</path>
        <kind>utility class</kind>
        <symbol>getRowForY</symbol>
        <lines>76-108</lines>
        <reason>Calculates deterministic row ID based on Y coordinate using formula row-${Math.floor((y - startY) / rowHeight)}. Handles negative Y coordinates.</reason>
      </artifact>
      <artifact>
        <path>src/pages/MagicCanvas.jsx</path>
        <kind>React component</kind>
        <symbol>handleCanvasChange</symbol>
        <lines>246-274</lines>
        <reason>Existing onChange handler that tracks canvas state changes. Integration point for useRowSystem hook to monitor element changes. Use requestAnimationFrame-based throttling and Map-based diff detection for performance.</reason>
      </artifact>
      <artifact>
        <path>src/pages/MagicCanvas.jsx</path>
        <kind>React component</kind>
        <symbol>Excalidraw integration</symbol>
        <lines>10-13</lines>
        <reason>Shows existing Excalidraw API integration pattern with onChange events and getSceneElements() for element detection.</reason>
      </artifact>
    </code>
    <dependencies>
      <framework name="React" version="18.3.1" usage="Component hooks and state management for useRowSystem"/>
      <framework name="Excalidraw" version="0.18.0" usage="Canvas API for element detection and onChange events"/>
      <framework name="Vite" version="6.0.7" usage="Build tool and development server"/>
      <framework name="Tailwind CSS" version="3.4.17" usage="Styling for MagicCanvas component"/>
      <library name="react-helmet-async" version="2.0.5" usage="Page metadata management"/>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Assignment must complete within 100ms of stroke completion to meet performance targets</constraint>
    <constraint>Use existing RowManager class - do not create new row management system</constraint>
    <constraint>Follow unidirectional data flow: Excalidraw → RowManager → IndexedDB</constraint>
    <constraint>Element assignment must be based on center Y coordinate (average of minY and maxY)</constraint>
    <constraint>Row IDs must be deterministic format: "row-{index}" based on Y position</constraint>
    <constraint>Implement 50ms debounce for rapid drawing scenarios to prevent performance issues</constraint>
    <constraint>Row assignments must persist through pan/zoom operations (stable row IDs)</constraint>
    <constraint>Use existing logger.js for debugging and diagnostic events</constraint>
    <constraint>Follow React hook patterns established in existing Texo codebase</constraint>
    <constraint>Element diff detection must handle new, modified, and deleted elements using Map-based O(1) lookups</constraint>
    <constraint>Implement requestAnimationFrame-based debouncing for 60fps performance during rapid drawing</constraint>
    <constraint>Handle multi-row spanning elements with primary row assignment based on center Y coordinate</constraint>
    <constraint>Use WeakMap for element metadata to prevent memory leaks</constraint>
    <constraint>Implement graceful fallback for element assignment failures</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>RowManager.assignElement</name>
      <kind>class method</kind>
      <signature>assignElement(element: ExcalidrawElement): string</signature>
      <path>src/utils/rowManager.js</path>
    </interface>
    <interface>
      <name>RowManager.removeElement</name>
      <kind>class method</kind>
      <signature>removeElement(elementId: string): void</signature>
      <path>src/utils/rowManager.js</path>
    </interface>
    <interface>
      <name>RowManager.getRowForY</name>
      <kind>class method</kind>
      <signature>getRowForY(y: number): Row | null</signature>
      <path>src/utils/rowManager.js</path>
    </interface>
    <interface>
      <name>Excalidraw.onChange</name>
      <kind>event callback</kind>
      <signature>onChange(elements: ExcalidrawElement[], appState: AppState, files: File[]): void</signature>
      <path>src/pages/MagicCanvas.jsx</path>
    </interface>
    <interface>
      <name>Excalidraw.getSceneElements</name>
      <kind>API method</kind>
      <signature>getSceneElements(): ExcalidrawElement[]</signature>
      <path>src/pages/MagicCanvas.jsx</path>
    </interface>
  </interfaces>
  <tests>
    <standards>Unit tests using Vitest with jsdom environment. Test files located in src/utils/__tests__/ directory. Follow existing patterns from rowManager.test.js with comprehensive coverage of public methods. Performance tests to validate &lt;100ms assignment timing. Integration tests for browser-based element assignment workflow.</standards>
    <locations>src/utils/__tests__/useRowSystem.test.js (new), src/utils/__tests__/rowManager.test.js (existing), manual browser testing for complete user workflow</locations>
    <ideas>Test AC1: Mock Excalidraw onChange events and verify element assignment. Test AC2: Performance test with timing measurement. Test AC3: Verify center Y coordinate calculation. Test AC4: Simulate element movement across row boundaries. Test AC5: Test assignment persistence during pan/zoom operations. Test AC6: Test element deletion and row cleanup. Test AC7: Test undo/redo operations with row assignment restoration.

Advanced Testing: Element diff detection with Map-based O(1) lookups. Performance testing with requestAnimationFrame debouncing. Edge case testing for multi-row spanning elements. Memory leak testing with WeakMap usage. Error recovery testing with fallback mechanisms. Integration testing with rapid drawing scenarios (100+ elements). Conflict resolution testing for overlapping elements.</ideas>
  </tests>
  
  <implementationPatterns>
    <pattern name="Element Diff Detection">
      <description>Use Map-based O(1) lookups for comparing previous vs current element states. Track new, modified, and deleted elements separately. Only compare properties that affect row assignment (x, y, width, height, isDeleted).</description>
      <code>
const diffElements = (currentElements, previousMap) => {
  const currentMap = new Map(currentElements.map(el => [el.id, el]));
  const diff = { new: [], modified: [], deleted: [] };
  
  // Find new and modified elements
  for (const [id, element] of currentMap) {
    if (!previousMap.has(id)) {
      diff.new.push(element);
    } else if (hasElementChanged(previousMap.get(id), element)) {
      diff.modified.push(element);
    }
  }
  
  // Find deleted elements
  for (const [id] of previousMap) {
    if (!currentMap.has(id)) {
      diff.deleted.push(id);
    }
  }
  
  return diff;
};
      </code>
    </pattern>
    
    <pattern name="Performance-Optimized Debouncing">
      <description>Use requestAnimationFrame-based debouncing with 60fps throttling. Batch process element changes to maintain performance during rapid drawing. Implement 50ms debounce for assignment operations.</description>
      <code>
const useDebouncedProcessing = () => {
  const processingRef = useRef(false);
  const pendingRef = useRef(new Set());
  
  const scheduleProcessing = useCallback((callback) => {
    pendingRef.current.add(callback);
    
    if (!processingRef.current) {
      processingRef.current = true;
      
      requestAnimationFrame(() => {
        const callbacks = Array.from(pendingRef.current);
        pendingRef.current.clear();
        processingRef.current = false;
        
        callbacks.forEach(cb => cb());
      });
    }
  }, []);
  
  return { scheduleProcessing };
};
      </code>
    </pattern>
    
    <pattern name="Multi-Row Element Handling">
      <description>For elements spanning multiple rows, use center Y coordinate for primary assignment. Log spanning events for debugging. Handle edge cases where element boundaries exceed row limits.</description>
      <code>
const assignSpanningElement = (element, rowManager) => {
  const yCoords = element.y || [];
  if (yCoords.length < 4) return null;
  
  const minY = Math.min(...yCoords);
  const maxY = Math.max(...yCoords);
  const centerY = (minY + maxY) / 2;
  
  const startRow = rowManager.getRowForY(minY);
  const endRow = rowManager.getRowForY(maxY);
  
  if (startRow?.id === endRow?.id) {
    return rowManager.assignElement(element);
  }
  
  // Multi-row case: use center Y for primary assignment
  logger.debug('useRowSystem', 'Element spans multiple rows', {
    elementId: element.id,
    minY, maxY, centerY,
    primaryRow: rowManager.getRowForY(centerY)?.id
  });
  
  return rowManager.assignElement(element);
};
      </code>
    </pattern>
    
    <pattern name="Memory Management">
      <description>Use WeakMap for element metadata to prevent memory leaks. Implement periodic cleanup of stale references. Use WeakRef for large objects that shouldn't prevent garbage collection.</description>
      <code>
const elementMetadataRef = new WeakMap();

const getElementMetadata = (element) => {
  if (!elementMetadataRef.has(element)) {
    elementMetadataRef.set(element, {
      lastAssignedRow: null,
      assignmentCount: 0,
      lastProcessed: 0
    });
  }
  return elementMetadataRef.get(element);
};
      </code>
    </pattern>
    
    <pattern name="Error Recovery">
      <description>Implement graceful fallback for element assignment failures. Use try-catch blocks with logging. Provide simple Y-based assignment as fallback when complex logic fails.</description>
      <code>
const assignElementWithFallback = (element, rowManager) => {
  try {
    return assignSpanningElement(element, rowManager);
  } catch (error) {
    logger.warn('useRowSystem', 'Primary assignment failed, using fallback', {
      elementId: element.id,
      error: error.message
    });
    
    // Fallback: simple Y-based assignment
    const yCoords = element.y || [];
    if (yCoords.length > 0) {
      const centerY = (Math.min(...yCoords) + Math.max(...yCoords)) / 2;
      const row = rowManager.getRowForY(centerY);
      return row?.id || null;
    }
    
    return null;
  }
};
      </code>
    </pattern>
  </implementationPatterns>
</story-context>